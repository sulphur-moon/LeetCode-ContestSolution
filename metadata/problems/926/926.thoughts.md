**思路：**

本题有多种思路

1. 用 `cnt0[i]` 表示第 `i` 位（包含）之前有多少个 `0`，那么我们只需要寻找一个分割点 `i`，让 `i` 之前的 `1` 和 `i` 之后的 `0` 数目之和最小。
2. 从头遍历，从第一个 `1` 开始 `0` 的数目和 `1` 的数目赛跑，每次 `0` 的数目超过 `1` 的数目翻转前面的所有 `1`，再找到下一个 `1` 从新计数，以此类推。最后`0`的数目不超过`1`的数目翻转后面剩下的`0`。程序中只需要计数，不需要真实的翻转。
3. 某一位为 `1` 时，前面一位是 `0` 或者 `1` 都可以；某一位为 `0` 时，前面一位只能为 `0`。
4. 用 `one` 表示到第 `i` 位为止 `1` 的个数，用 `d` 表示 `1` 的个数减去 `0` 的个数，遍历时维护 `d` 的最小值，即可得到结果为 `d + len(S) - one`。

时间复杂度 $O(N)$

空间复杂度 $O(N)$

