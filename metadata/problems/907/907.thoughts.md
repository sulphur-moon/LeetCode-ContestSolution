**思路：**

考虑从 `A` 中的每个元素 `A[i]`，如果求出包含 `A[i]` 并以 `A[i]` 为最小元素的所有子数组个数 `n[i]`，则元素 `A[i]` 对答案 `ans` 的贡献为 `n[i] * A[i]`，那么我们可以先求包含 `A[i]` 并以 `A[i]` 为最小元素的最长子数组，如果 `A[i]` 左边第一个小于 `A[i]` 的元素为 `A[left]`，`A[i]` 右边第一个小于 `A[i]` 的元素为 `A[right]`，则包含 `A[i]` 并以 `A[i]` 为最小元素的最长子数组为 `A[left+1:right]`，满足以 `A[i]` 为最小元素的所有子数组个数 `n[i] = (i-left)*(right-i)`。我们用 `left[i]` 表示 `A[i]` 左边第一个小于 `A[i]` 元素的位置，用 `right[i]` 表示 `A[i]` 右边第一个小于 `A[i]` 元素的位置，`left` 数组初始值为 `-1`，`right` 数组初始值为 `len(A)`，求解 `left` 和 `right` 可以用单调栈来实现，可以两遍遍历，也可以一遍遍历，更优化的写法还可以一边遍历一边求解 `ans`。

时间复杂度 $O(N)$

空间复杂度 $O(N)$

**图解：**

![图解](http://qiniu.wenyuetech.cn/907-1.gif)

