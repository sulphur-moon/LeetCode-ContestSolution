**思路：**

顺序遍历或者倒序遍历都可以。以从后往前的倒序遍历为例，用 `fruit` 数组表示两个水果种类代号，将 `tree[len(tree)-1]` 加入到 `fruit` 中，然后指针从最后一棵树开始，往前遍历寻找另一种不同水果。如果找不到，说明只有一种水果，直接返回 `len(tree)`。如果找到了，将第二种水果加入到 `fruit` 中，用 `start` 和 `stop` 数组表示两个水果在区间的起始位置和结束位置，则每扫描一个区间，最大长度为 `max(stop)-min(start)`，继续扫描下个区间，这时要判断篮子里保存哪个水果，所以需要比较两个水果的起始位置，保留 `start` 值较小的那种类型的水果，将另一种水果用当前指针新发现的水果替换，保留水果的 `stop` 值还要用被替换水果的 `start` 值更新，即 `stop[0] = min(stop[0], start[1] - 1)`。

时间复杂度 $O(N)$
空间复杂度 $O(1)$

**图解：**

![图解](http://qiniu.wenyuetech.cn/904-1.gif)

