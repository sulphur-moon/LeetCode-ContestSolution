**思路：**

先统计字符串中每个字符出现的次数，用 `left[i]` 表示位置 `i` 左侧连续相等字符的最大长度，用 `right[i]` 表示位置 `i` 右侧连续相等字符的最大长度，分别自左向右和自右向左扫描一次，求得 `left[i]` 和 `right[i]`。

由于最多只允许交换一次字符，我们可以遍历一次求得答案。当我们遍历位置 `i` 时，分两种情况讨论：

1. 当位置 `i` 两侧的字符相等时，我们查看 `left[i] + right[i]` 是否小于该字符出现的次数：如果小于，那么说明有其他位置的该字符可以交换到 `i` 位置，将左右两边连续的字符连接起来，形成长度为 `left[i] + right[i] + 1` 的连续字符，亦或是多的那个字符本身就在 `i` 位置，我们无需做任何操作。如果等于，那么我们可以将右侧连续字符的最后一个字符交换到 `i` 位置，或者把左侧连续字符的第一个字符交换到 `i` 位置，形成长度为 `left[i] + right[i]` 的连续字符。
2. 当位置 `i` 两侧的字符不相等时，我们分别查看 `left[i]` 和 `right[i]` 是否小于各自字符出现的次数：如果小于，则用 `left[i] + 1` 或 `right[i] + 1` 更新答案；如果等于，则直接用 `left[i]` 和 `right[i]` 更新答案。

**图解：**

![图解](http://qiniu.wenyuetech.cn/1156-1.png)

