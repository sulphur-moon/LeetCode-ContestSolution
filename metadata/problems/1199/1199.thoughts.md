**思路：**

这道题目类似于构建哈夫曼树，可以采用贪心的方法解决。根据题意，初始情况只有一个工人，而且一个工人只能建造一个街区，那么如果我们要建造 n 个街区，必然要将工人分裂 n - 1 次。不同方案的区别就在于，每一步分裂的工人是有两个选择，一个选择是直接去建造街区，另一个选择是开始下一步的分裂。所以我们可以将分裂过程看成一棵二叉树，初始的工人在根节点，每分裂一次，就生成两个儿子，消耗 `split` 个单位时间，如果不分裂，就变成叶子节点建造街区。显然，随着树深度的增加，分裂花费的时间也在增加，深度为 `depth` 的节点，所需分裂时间是 `depth * split`。所以，要想总花费时间最小，就要给深度大的节点分配建造时间少的街区，给深度小的节点分配建造时间多的街区，最终答案就是每个节点的 `block[i] + depth * split` 取最大值。

树的构造过程和哈夫曼树构造过程相似，用优先队列，每次取时间花费最少的两个节点，增加他们的分裂层数，合并为一个新节点，该节点的权值取两者权值较大的那个，再加上 `split`。如此操作 n - 1 次，得到最后的节点值就是答案。

**图解：**

![图解](http://qiniu.wenyuetech.cn/1199-1.gif)

